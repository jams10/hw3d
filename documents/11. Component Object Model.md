# 11. COM (Component Object Model)

##### COM은 마이크로소프트가 만든 기술로, 마이크로소프트가 만든 소프트웨어들의 토대(foundation)가 되는 기술임. Direct3D 또한 이 COM을 이용해 만들어졌음.

##### Direct3D API는 내부에 COM을 숨기고 있어 Direct3D를 사용하기 위해 COM을 마스터할 필요는 없음.

### Binary Compatibility (이진 호환성)
##### C++는 컴파일된 바이너리 오브젝트가 아닌 소스 코드를 통해 소프트웨어 컴포넌트 혹은 클래스를 재사용 하도록 설계되었음.
##### C++ 표준은 바이너리 데이터의 레이아웃과 관련해 많은 것을 지시하지 않음.

###### 이진호환성 그림

##### 이러한 문제점 외에도 수많은 문제들이 존재함. C++에서 바이너라 파일들이 다른 컴파일러들 사이에서 상호작용할 때 문제가 발생하며, 심지어 같은 컴파일러 내에서도 버전에 따라 호환성이 보장이 되지 않는 경우가 있음.
##### COM의 목표가 이진 호환성을 제공하는 것임. COM은 바이너리 레벨에서 재사용가능한 소프트웨어 객체를 만들고 연결할 때 표준을 제공함. 그래서 바이너리 파일들에 접근할 때 소스 코드에 접근하거나 재 컴파일이 필요가 없음.

### COM의 기능
##### - 프로그래밍 언어에 구애받지 않음(language agnostic). 언어가 COM 오브젝트에 대한 함수 포인터를 지원하면 COM을 사용할 수 있음. 또한 언어가 메모리 레이아웃에 대한 컨트롤을 제공해 줄 경우, COM 오브젝트를 만드는데 사용할 수 있음.
##### - 언어에 구애받지 않기 때문에 특정 언어의 메모리 할당 시스템을 사용할 수 없음. 그래서 독립적인 자원 할당 기능을 제공함.
##### - COM 쪽과 ID로 접근할 수 있는 객체들의 중앙 레지스트리로 관리되는 메모리에 오브젝트를 생성하는 언어에 독립적인 방법을 제공하는 Factory 함수들을 제공함. 그래서 모든 COM 객체들은 각자 유일한 ID를 가짐. 이를 통해 Factory에 ID를 건네주면 Factory는 중앙 레지스트리에서 객체를 찾고 생성하고 해당 객체와 인터페이스에 대한 핸들을 리턴해줌.
##### - 객체들과 상호작용할 때 인터페이스를 통해, 그들이 제공하는 기능을 통해 상호작용 함. 그래서 특정  타입에 묶지 않고 인터페이스에 묶음. 이 때문에 다형성이 지원됨.
##### - 언어 지원에 상관없이 캡슐화를 지원함.
##### - 쓰레드 안전 지원.
##### - 분산 컴퓨팅 지원.

### 인터페이스
##### COM을 이해하려면 인터페이스의 소프트웨어 설계 개념을 이해해야 함.
##### C#의 경우 한 번에 여러 개의 클래스를 상속 받을 수 없음. 그러나 여러 개의 인터페이스를 받아 구현할 수 있음.
##### C++의 경우 인터페이스 키워드가 없는 대신에 여러 개의 클래스를 상속받을 수 있는데, 인터페이스를 구현하기 위해 base 클래스 들을 모두 순수 가상 클래스로 만들어서 상속 받게 하면 됨. 이렇게 하면 또 장점이 여러 개의 클래스들을 상속 받을 때 일어나는 dreaded diamond 문제를 피할 수 있음.
##### *순수 가상 클래스 : 함수 정의부가 없고 그냥 순수 가상 함수들로만 이루어진 클래스.

##### COM에서는 factory 함수에게 COM 객체를 만들어달라고 요청하면, COM 쪽에서 객체를 생성하고 사용자에게 해당 객체에 대한 인터페이스 포인터 혹은 핸들을 넘겨줌. 그래서 이 객체들을 실제 데이터 타입의 측면에서 다루는 것이 아니라 인터페이스 측면에서 다루는 것임. 이 덕분에 우리가 작성하는 코드에서는 인터페이스 측면에서만 COM 객체들을 다루기 때문에 COM 라이브러리에서 COM 객체를 수정할 경우 클라이언트 쪽에서 우리가 작성한 코드를 COM 객체 수정 여부에 상관없이 그대로 사용할 수 있음.

### COM 인터페이스
#### [IUnknown 인터페이스](https://docs.microsoft.com/ko-kr/windows/win32/api/unknwn/nn-unknwn-iunknown)
##### IUnknown 인터페이스는 모든 COM 객체들에서 지원하는 인터페이스. COM 객체들을 관리할 때 필요한 함수들을 가지고 있음.
##### [AddRef / Release]
##### COM 오브젝트를 만들 거나 제거할 때 new / delete를 사용하지 않음. new와 delete는 C++에 한정되는 연산자일 뿐임.
##### COM factory 함수를 호출하면 COM은 우리를 위해 오브젝트를 만들어줌. COM이 모든 자원들을 할당하고 COM이 생성한 오브젝트에 대한 핸들을 넘겨주는 것.
##### 모든 COM 오브젝트들은 레퍼런스 카운트를 가지고 있음. 스마트 포인터 처럼 해당 레퍼런스 카운트를 증가시킬 때는 AddRef 함수를, 감소 시킬때는 Release 함수를 호출해서 레퍼런스 카운트가 0이 되면 자동으로 해당 객체가 소멸됨.
##### [QueryInterface]
##### 인터페이스 ID를 건네주면, 오브젝트가 해당 ID에 해당하는 인터페이스를 지원하는 경우에 호출할 때 같이 건네준 포인터에 해당 오브젝트의 인터페이스의 주소를 저장해줌.
##### *UUID(Universal Unique Identifiers) : 인터페이스들을 구별하기 위한 ID

##### COM 오브젝트를 직접적으로 사용하기 위해서는 CoInitialize / CoUninitialize 등으로 초기화 및 해제를 해주어야 함. Direct3D의 경우에는 lightweight COM을 사용(간접적으로 COM 사용), 서브 시스템의 초기화는 사실상 필수적이지 않음.

##### COM 오브젝트는 v table에 대한 포인터를 가짐. 모든 v 테이블은 인터페이스를 표현하는 함수 포인터들의 구조체 혹은 배열. C++의 가상 함수 테이블 처럼 이런 구조를 활용해 런타임에 가상 함수들이 동적 바인딩 되도록 함.



